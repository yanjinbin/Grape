chapter3: 对象的共享和发布

同步不单单指的是确定原子操作的临界区 ， 也意味着 内存可见性
我们希望一个线程修改了对象的状态之后，能够通知到另外一个线程（或者说，对象的状态对其他内存是可见的）

可见性： 违背我们的自觉 


----

非 volatile 类型的 64位的 long 和 double 变量  存在 非原子的64位操作

volatile 和 加锁的区别在于  volatile 只能保证可见性 但是不能保证 原子性

什么时候使用 volatile 变量 ：


---

this 引用逸出

todo 

----

线程封闭


P35 局部变量 和 ThreadLocal 就是采用的是线程封闭技术  但是 确保封闭的对象不会从线程中逸出 

- 1.ad-hoc 线程封闭

-2  栈封闭

-3 ThreadLocal引入了暗含的耦合性是什么是意思呢 nextodo ?


---
P3.4 创建不可变对象的3个条件：
1 对象创建之后状态就不再改变
2 对象所有的域都是 final 
3 对象是正确创建的（暨对象创建过程中没有this 引用逸出）


----
 创建 发布 共享（共享哪些权益和原则）
P45 解释了对象安全发布需要的原则 

----

P42 实例封闭的意思  比如 hashset 本身 不是线程安全的数据结构，但是 我可以通过 加锁  来实现 拥有HashSet 的对象 的线程安全，这叫做实例封闭



P61 客户端加锁  
使用 X 本身用于其同步机制的方法来保护客户端线程安全  就叫做 客户端加锁



----

线程封闭技术：


----

P43
final 域